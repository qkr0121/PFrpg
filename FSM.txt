FSM(Finite State Machine)

- 유한 개의 상태를 가지고 주어지는 입력에 따라
  다른 상태로 전환시키는 장치 또는 모델
- EX)유니티 애니메이션 시스템

장점 : 쉬운 구현, 오류수정 용이, 유연한 코드, 직관적인 코드

구현
Simple : if-then, switch-case, 상태들을 표현하는 열거형(enum)
장단점 : 구현이 쉽지만, 행동정의가 어렵고 상태의 개수가 늘어남에 따라 코드가 복잡해진다.

코루틴 : ChangeState(PlayerState newState) 메서드로 FSM 구현

더 나은 FSM 
에이전트와 상태의 분리
- 각 상태를 에이전트 내부에 작성하는 것이 아닌 에이전트 외부에 존재하는 별개의 클래스로 작성
- 명확, 유연한 구조를 만들수 있고 코드의 재사용을 줄여준다.

내장된 규칙들
- 각 상태들 내부에 상태 전환을 위한 규칙들을 내장시키는 방법이다.
- 자신의 상태의 변경을 자기 스스로 판단하여 교체한다.

단계별 FSM : if-then / switch-case -> 하나의 에이전트가 사용할 수 있는 FSM
	-> 여러 에이전트가 사용할 수 있는 FSM -> 에이전트들 간의 소통을 위한 전보 전달 시스템

상태패턴
 - 객체의 상태에 따라 동작을 다르게 처리하는 디자인 패턴
 - 에이전트가 취할 수 있는 동작을 클래스로 구현 -> 모든 상태클래스는 공통된 기반 클래스를 상속받아 자료형을 통
 - 에이전트의 상태를 바꿔주는 메소드 구현 : ChangeState()
   -> 각 상태는 진입할 때나(enter) 나갈 때(exit) 취하는 행동에 대해 정의되기를 원함(유연성을 위해)

일반적인 State(Enter, Execute, Exit) 클래스는 Student 외 다른 에이전트가 사용할 수 없다.
- Enter(Student entity)의 형식이기 때문에

-> 일반화 프로그래밍을 이용하면 Student 이외의 에이전트가 사용할 수 있다.(재사용 가능해진다)
- State<T> : where T : class,  Enter(T entity)

StateMachine 클래스의 필요성
- 상태 관리에 대한 코드가 에이전트 내부에 있으면 다른 에이전트를 제작할 때 또 작성해야한다.
- 상태와 연관된 모든 데이터를 하나의 클래스로 캡슐화, 재사용을 줄인다.
- 현재 상태에 대한 관리, 상태 변경 등에 대한 처리를 위임할 수 있다.

전역 상태(Global State)
- 에이전트가 어떤 상태를 수행할 때, 모든 상태에서 지속적으로 업데이트 되어야 하는 조건 논리가 있는 상태
- ex : 게임속 에이전트는 여러 행동을 할 때, 지속적으로 HP를 체크해주어야 죽지 않고 원하는 행동을 할 수 있다.
- 방법 :
	- 1. 에이전트가 소유하고 있는 모든 상태에 조건 논리 추가 -> 상태가 생길 때마다 또 모든상태에 추가해야함
	- 2. 에이전트의 Updated() 메소드 내부에 조건 논리 추가 -> 상태에 대한 논리를 에이전트 내부에 작성해야 함
 	- 3. 현재 상태와 별개로 작동하는 상태 변수를 제작

상태 블립(State Blip)
- 에이전트의 상태가 변경될 때, 바로 직전 상태로 복귀한다는 조건하에 다른 상태로 변경하는 것
- 이전 상태를 기억해두고 상태 블립이 그 상태로 전환시킬 수 있게 해야 한다.

유일 객체 디자인패턴(singleton)

네스트요소, 태그파라미터
$"<color={personalColor}><b>{entityName}</b></color> : {text}"